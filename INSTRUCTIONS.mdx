# Tests End To End

### üí° Comprendre les Tests End To End

## üìù Tes notes

D√©taille ce que tu as appris ici,¬†sur¬†une¬†page¬†[Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Les tests End-to-End (`E2E`) sont con√ßus pour valider le fonctionnement global d'une application, du `front-end` au `back-end`, en passant par toutes les couches interm√©diaires. Contrairement aux tests unitaires ou d'int√©gration, les tests `E2E` simulent le parcours r√©el d'un utilisateur, en interagissant avec l'interface utilisateur et en testant les fonctionnalit√©s dans leur ensemble.

Avec [**Cypress**](https://docs.cypress.io/app/get-started/install-cypress), un outil populaire pour les tests `E2E`, nous pouvons √©crire des tests rapides et robustes qui imitent les actions de l'utilisateur (clics, remplissage de formulaires, navigation). L'objectif est de garantir que l'application r√©pond correctement aux interactions utilisateur et fonctionne comme pr√©vu dans un environnement proche de la production.

Dans cette section, nous allons explorer comment configurer et utiliser `Cypress` pour tester notre application de mani√®re compl√®te et fiable.

- D√©pendances

```tsx
 pnpm add cypress -D
```

- Script Install

```tsx
pnpm dlx cypress install
```

üìë Le lien vers la doc [https://docs.cypress.io/app/get-started/install-cypress](https://docs.cypress.io/app/get-started/install-cypress)

Les tests E2E doivent reproduire **les conditions r√©elles** pour garantir que l'application fonctionne de bout en bout. L‚Äôobjectif est de valider **toutes les couches** (UI, API, base de donn√©es) √† travers des sc√©narios proches de l‚Äôexp√©rience utilisateur.

### **Principes cl√©s :**

1. **Limitation des `Mocks`** :
   - Les `mocks` et conteneurs sont minimis√©s. On teste un syst√®me complet, proche de la production.
2. **Actions utilisateur compl√®tes** :
   - Les interactions (clics, formulaires) sont simul√©es via un **navigateur embarqu√©** (`Cypress`, `Playwright`).
   - Chaque action doit inclure toutes les √©tapes : interface, API, persistance.
3. **Validation de bout en bout** :
   - Les donn√©es doivent circuler correctement entre pr√©sentation, logique m√©tier et stockage, pour √©viter des surprises en production.

### **Exemple pratique :**

- L‚Äôutilisateur se connecte, ajoute un produit au panier, passe une commande.
- Le test v√©rifie les interactions UI, les r√©ponses API et l‚Äôenregistrement dans la base de donn√©es.

### **Pourquoi cette approche ?**

- **Fiabilit√©** : D√©tecte les erreurs inter-couches.
- **Exp√©rience utilisateur** : Valide les flux critiques.
- **Proximit√© production** : R√©duit les bugs en prod.

**`Cypress` : Exemple de Tests**

```tsx
describe('Home Page - Basics', () => {
  it('should load the homepage successfully', () => {
    // Charger la page d'accueil
    cy.visit('/');

    // V√©rifier que le titre de la page contient le texte attendu
    cy.title().should('include', 'Accueil');

    // V√©rifier que le header principal est visible
    cy.get('h1').should('be.visible').and('contain', 'Bienvenue sur notre site');
  });
});
```

### **`Cypress` : Les modes**

Deux modes sont disponibles avec `Cypress` :

- Interactif

`Cypress` lance une interface graphique qui permet de visualiser concr√®tement les tests, quelles pages, actions etc‚Ä¶ C‚Äôest utilise pour cr√©er les tests en local

```bash
npx cypress open
#package.json
"e2e": "cypress open",
```

- headless : (sans √©cran)

Utilise pour ex√©cuter les tests dans un terminal ou sur un `CI`

```bash
npx cypress run
#package.json
"e2e:ci": "cypress run",
```

‚ö†Ô∏è `Cypress` va se connecter sur un Server pour ex√©cuter les tests

```tsx
import {defineConfig} from 'cypress'
import {config} from 'dotenv'

config({path: '.env.test'})

export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
    baseUrl: 'http://localhost:3000',
    env: {
      email: process.env.CYPRESS_EMAIL,
      password: process.env.CYPRESS_PASSWORD,
    },
  },
})
// a ajouter .env.test
//CYPRESS_EMAIL='admin@gmail.com'
//CYPRESS_PASSWORD='MDp'
```

### **Pr√©parer le `build` (`env test`)**

Pour pr√©parer un `build` de production mais avec un environnement de tests

```bash
 "build:test": "dotenv -e .env.test -- next build",
 "start:test": "dotenv -e .env.test -- next start",
```

### **start-server-and-test**

Pour d√©marrer un server et lancer les tests nous utiliseront un utilitaire : `start-server-and-test`, celui ci permet de

- Lancer une commande qui d√©marre le serveur
- Attendre que l‚Äôadresse r√©ponde
- Lancer une commande de test

```bash
start-server-and-test <commande_server> http://127.0.0.1:3000 <commande_tests>
```

```bash
 "e2e:test": "start-server-and-test start:test http://127.0.0.1:3000 e2e",
```

### **R√©cap des commandes tests**

- Lancement des tests avec `vitest`:
  ```bash
  pnpm test
  ```
- Lancement des tests `e2e` avec affichage (reset db + build):
  ```bash
  pnpm e2e:test-clean
  ```
- Lancement des tests `e2e` avec affichage (sans reset db + build):
  ```bash
  pnpm e2e:test
  ```
- Lancement des tests `e2e` en `CLI` seulement (avec reset db + build):
  ```bash
  pnpm e2e:test-clean-ci
  ```
- Lancement des tests `e2e` en `CLI` seulement (sans reset db + build):
  ```bash
  pnpm e2e:test-ci
  ```

## Exercice

Dans cet exercice, tu vas devoir tester la `home` avec des fonctions basiques de l‚Äôapi de `cypress`

- `cy.visit('/')`
- `cy.get('p')`
- etc‚Ä¶

Fichiers

- `cypress/e2e/home.final.ts`

## Bonus

### 1. üöÄ Commandes personnalis√©es

Il y a des actions que l‚Äôon doit r√©p√©ter souvent dans nos tests : Exemple

- Aller sur la page de connexion
- Entrer le login password
- Se connecter
- V√©rifier que l‚Äôon est bien connect√©
- etc‚Ä¶

R√©p√©ter ces √©tapes sur chaque test peut vite alourdir les tests. Cela duplique beaucoup de code et c‚Äôest difficile √† maintenir.

Exemple commun √† beaucoup de tests c√¥t√© connect√© (`dashboard`)

```tsx
it('Connection Dashboard', () => {
    cy.visit('/')
    // Attendre que la page soit charg√©e
    cy.get('h2').contains('Se Connecter').parent('a').click()
    cy.url().should('include', '/sign-in')
    cy.get('h1').contains('Se connecter').should('be.visible')
    cy.findByPlaceholderText('Email').type('admin@gmail.com')
    cy.findByPlaceholderText('Password').type('Azerty123')
    cy.findByRole('button', {name: 'Login'}).click()
    cy.url().should('contain', '/sign-in')
    cy.location('pathname').should('eq', '/logout')
    cy.findByRole('heading', {level: 1, name: 'D√©connexion'}).should(
      'be.visible'
    )
    cy.findAllByRole('link').each((link) => {
      if (link.find('span:contains("Dashboard")').length > 0) {
        cy.wrap(link).click()
      }
    })
    cy.url().should('contain', '/dashboard')
  })
```

Pour cela, il existe les commandes personnalis√©es. Par exemple la commande `visitSignIn`

```tsx
//command.ts

Cypress.Commands.add('visitSignIn', () => {
  cy.visit('/')
  cy.get('h2').contains('Se Connecter').parent('a').click()
  cy.url().should('include', '/sign-in')
  cy.get('h1').contains('Se connecter').should('be.visible')
})

//test.cy.ts
it('Sign-in', () => {
    cy.visitSignIn()
 })
```

‚ö†Ô∏è Pour que `typescript` reconnaisse ces commandes personnalis√©es, nous utiliseront un fichier `cypress.d.ts`

```tsx
import {mount} from 'cypress/react'

declare global {
  namespace Cypress {
    interface Chainable {
      mount: typeof mount
      visitSignIn(): Chainable<void>
      ... //other custom commands
    }
  }
}
```

**üê∂ Step 1 :** Dans cet exercice, tu vas devoir cr√©er les commandes personnalis√©es suivantes :

- `visitShopAdmin` qui se base sur :
  - `visitSignIn`
  - `fillAuthForm` : Remplissage du formulaire login
  - `login` : Se connecte (clique button)

**üê∂ Step 2 :** Utilise ces commandes personnalis√©es dans \*\*\*\*`server-component.cy.ts` pour acc√©der √† la page d‚Äôadministration de la boutique.

Fichiers

- `cypress/e2e/server-component.cy.ts`
- `cypress/support/commands.ts`

### 2. üöÄ CRUD Formulaire Product

Maintenant que nous avons des commandes personnalis√©es pour se connecter √† l‚Äôadministration, nous allons pouvoir nous concentrer sur les tests fonctionnels de la page `admin` `shop`. Les op√©rations que nous auront √† r√©p√©ter plusieurs fois sont li√©es au remplissage du formulaire produit.

**üê∂** Step 1 : Dans cet exercice, tu vas devoir cr√©er les commandes personnalis√©es suivantes

- `fillProductForm`
- `createProduct`
- `updateProduct`
- `deleteProduct`

  **üê∂** Step 2 : Les tests

**Liste des tests pour "`CRUD operations for Product`"**

**1.** Lecture des produits existants (`"Read product's list"`)

**Objectif** : V√©rifier que la liste des produits existants est affich√©e correctement dans l'interface d'administration.

- **√âtapes** :
  1. Visiter la page d'administration des produits avec `cy.visitShopAdmin()`.
  2. Localiser le tableau contenant les produits (`tbody > tr`).
  3. V√©rifier que la liste contient un produit existant, comme `"Wilson Pro Staff Tennis Racket"`.

**2.** Cr√©ation d'un produit (`"Create product"`)

**Objectif** : Ajouter un nouveau produit √† la liste des produits et v√©rifier qu'il est correctement sauvegard√©.

- **√âtapes** :
  1. Visiter la page d'administration des produits avec `cy.visitShopAdmin()`.
  2. V√©rifier que le produit n'est pas encore pr√©sent avec `cy.containProductTitle(product.title)`.
  3. Cr√©er un produit en utilisant la commande personnalis√©e `cy.createProduct(product)`.
  4. V√©rifier qu'un message de confirmation s'affiche avec `cy.containToastMessage('Product saved')`.
  5. Confirmer que le nouveau produit est ajout√© √† la liste avec `cy.containProductTitle(product.title, true)`.

**3.** Mise √† jour d'un produit (`"Update product"`)

**Objectif** : Modifier un produit existant et v√©rifier que les modifications sont correctement enregistr√©es.

- **√âtapes** :
  1. Visiter la page d'administration des produits avec `cy.visitShopAdmin()`.
  2. V√©rifier que le produit √† modifier existe avec `cy.containProductTitle(product.title, true)`.
  3. S√©lectionner le produit existant dans le tableau (`cy.get('tbody').find('tr').contains(product.title)`).
  4. Mettre √† jour les informations du produit avec `cy.updateProduct(updateProduct)`.
  5. V√©rifier qu'un message de confirmation s'affiche avec `cy.containToastMessage('Product saved')`.
  6. V√©rifier que l'ancien titre du produit n'est plus affich√© avec `cy.containProductTitle(product.title)`.
  7. Confirmer que le nouveau titre est affich√© avec `cy.containProductTitle(updateProduct.title, true)`.

**4.** Suppression d'un produit (`"Delete product"`)

**Objectif** : Supprimer un produit de la liste et s'assurer qu'il n'appara√Æt plus.

- **√âtapes** :
  1. Visiter la page d'administration des produits avec `cy.visitShopAdmin()`.
  2. Supprimer le produit en utilisant son titre avec `cy.deleteProduct(updateProduct.title)`.
  3. V√©rifier qu'un message de confirmation s'affiche avec `cy.containToastMessage('Product deleted')`.
  4. Confirmer que le produit n'est plus pr√©sent dans la liste avec `cy.containProductTitle(updateProduct.title)`.

Fichiers

- `cypress/e2e/server-component.cy.ts`
- `cypress/support/commands.tse`

### 3. üöÄ All Tests for `CI`

```tsx
 "test": "vitest  --run && e2e:test-clean-ci",
```

## Aller plus loin

üìë Le lien vers la doc [https://docs.cypress.io/app/core-concepts/introduction-to-cypress](https://docs.cypress.io/app/core-concepts/introduction-to-cypress)

## Ils vont t‚Äôaider

- **üê∂ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ü§ñ Ash le Robot** : _Ash le Robot te donnera du code utile._
- **üöÄ Julia La roquette** : _Julia te donnera des d√©fis suppl√©mentaires._
- **‚õèÔ∏è Hulk le Marteau** : _Quand du code √† supprimer est pr√©sent_
- **üë®‚Äç‚úàÔ∏è Hugo le chef de projet** : _Va t'aider sur les sp√©cifications du projet_

## üêú Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20Mastery&entry.1430994900=8.Next%20Testing&entry.533578441=09%20tests-end2end).
